window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "dapy", "modulename": "dapy", "kind": "module", "doc": "<p>Project: dapy</p>\n\n<p>This package provides a set of tools for prototyping distributed algorithms.</p>\n\n<p>The project is structures into three main modules:</p>\n\n<ul>\n<li><code>.core</code>: Contains the core components of the library, providing the basis for\ndefining distributed algorithms and representing distributed executions.</li>\n<li><code>.algo</code>: Contains implementations of various distributed algorithms, showcasing\nthe capabilities of the library.</li>\n<li><code>.sim</code>: Contains a simulation framework, allowing users to simulate and analyze the\nbehavior of distributed algorithms.</li>\n</ul>\n\n<p>Using this library consists of two main steps:</p>\n\n<ol>\n<li>Defining a distributed algorithm using the core components.</li>\n<li>Simulating the algorithm using the simulation framework.</li>\n</ol>\n"}, {"fullname": "dapy.algo", "modulename": "dapy.algo", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.algo.learn", "modulename": "dapy.algo.learn", "kind": "module", "doc": "<p>This module implements the \"Learn the Topology\" algorithm, from the .</p>\n"}, {"fullname": "dapy.algo.learn.PositionMsg", "modulename": "dapy.algo.learn", "qualname": "PositionMsg", "kind": "class", "doc": "<p>Message containing topology information from a process.</p>\n\n<p>Used to propagate knowledge of the network topology during the\nlearn topology algorithm.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>origin:</strong>  The identifier of the process whose neighbors are being shared.</li>\n<li><strong>neighbors:</strong>  The set of neighbor processes of the origin process.</li>\n</ul>\n", "bases": "dapy.core.event.Message"}, {"fullname": "dapy.algo.learn.PositionMsg.__init__", "modulename": "dapy.algo.learn", "qualname": "PositionMsg.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>,</span><span class=\"param\">\t<span class=\"n\">sender</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>,</span><span class=\"param\">\t<span class=\"n\">origin</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>,</span><span class=\"param\">\t<span class=\"n\">neighbors</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "dapy.algo.learn.PositionMsg.origin", "modulename": "dapy.algo.learn", "qualname": "PositionMsg.origin", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.pid.Pid"}, {"fullname": "dapy.algo.learn.PositionMsg.neighbors", "modulename": "dapy.algo.learn", "qualname": "PositionMsg.neighbors", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.pid.ProcessSet"}, {"fullname": "dapy.algo.learn.Start", "modulename": "dapy.algo.learn", "qualname": "Start", "kind": "class", "doc": "<p>Signal to initiate the topology learning algorithm in a process.</p>\n", "bases": "dapy.core.event.Signal"}, {"fullname": "dapy.algo.learn.Start.__init__", "modulename": "dapy.algo.learn", "qualname": "Start.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span>)</span>"}, {"fullname": "dapy.algo.learn.GraphIsKnown", "modulename": "dapy.algo.learn", "qualname": "GraphIsKnown", "kind": "class", "doc": "<p>Signal indicating that a process has learned the complete network topology.</p>\n", "bases": "dapy.core.event.Signal"}, {"fullname": "dapy.algo.learn.GraphIsKnown.__init__", "modulename": "dapy.algo.learn", "qualname": "GraphIsKnown.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span>)</span>"}, {"fullname": "dapy.algo.learn.LearnState", "modulename": "dapy.algo.learn", "qualname": "LearnState", "kind": "class", "doc": "<p>State maintained by a process during the topology learning algorithm.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>neighbors_i:</strong>  The set of neighbor processes (constant throughout execution).</li>\n<li><strong>proc_known_i:</strong>  The set of processes whose existence this process has learned.</li>\n<li><strong>channels_known_i:</strong>  The set of communication channels (directed edges) learned.</li>\n<li><strong>part_i:</strong>  Boolean flag indicating if this process has started (participated).</li>\n</ul>\n", "bases": "dapy.core.state.State"}, {"fullname": "dapy.algo.learn.LearnState.__init__", "modulename": "dapy.algo.learn", "qualname": "LearnState.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>,</span><span class=\"param\">\t<span class=\"n\">neighbors_i</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">proc_known_i</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">channels_known_i</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ChannelSet</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">part_i</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "dapy.algo.learn.LearnState.neighbors_i", "modulename": "dapy.algo.learn", "qualname": "LearnState.neighbors_i", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.pid.ProcessSet"}, {"fullname": "dapy.algo.learn.LearnState.proc_known_i", "modulename": "dapy.algo.learn", "qualname": "LearnState.proc_known_i", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.pid.ProcessSet"}, {"fullname": "dapy.algo.learn.LearnState.channels_known_i", "modulename": "dapy.algo.learn", "qualname": "LearnState.channels_known_i", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.pid.ChannelSet"}, {"fullname": "dapy.algo.learn.LearnState.part_i", "modulename": "dapy.algo.learn", "qualname": "LearnState.part_i", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "dapy.algo.learn.LearnGraphAlgorithm", "modulename": "dapy.algo.learn", "qualname": "LearnGraphAlgorithm", "kind": "class", "doc": "<p>Algorithm for distributed learning of the network topology.</p>\n\n<p>This algorithm enables each process to learn the complete network topology\nby having processes exchange their known neighbors. Each process initiates\nby sending its neighbors to all neighbors, then forwards received information\nto remaining neighbors until the complete graph is known.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>is_verbose:</strong>  Enable verbose output of algorithm events. Defaults to False.</li>\n</ul>\n", "bases": "dapy.core.algorithm.Algorithm"}, {"fullname": "dapy.algo.learn.LearnGraphAlgorithm.__init__", "modulename": "dapy.algo.learn", "qualname": "LearnGraphAlgorithm.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>, </span><span class=\"param\"><span class=\"n\">is_verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "dapy.algo.learn.LearnGraphAlgorithm.is_verbose", "modulename": "dapy.algo.learn", "qualname": "LearnGraphAlgorithm.is_verbose", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "dapy.algo.learn.LearnGraphAlgorithm.name", "modulename": "dapy.algo.learn", "qualname": "LearnGraphAlgorithm.name", "kind": "variable", "doc": "<p>Get the name of the algorithm.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The string \"Learn the Topology\".</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "dapy.algo.learn.LearnGraphAlgorithm.initial_state", "modulename": "dapy.algo.learn", "qualname": "LearnGraphAlgorithm.initial_state", "kind": "function", "doc": "<p>Create the initial state for a process.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pid:</strong>  The process identifier.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A LearnState initialized with the process's neighbors from the topology.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">algo</span><span class=\"o\">.</span><span class=\"n\">learn</span><span class=\"o\">.</span><span class=\"n\">LearnState</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.algo.learn.LearnGraphAlgorithm.on_event", "modulename": "dapy.algo.learn", "qualname": "LearnGraphAlgorithm.on_event", "kind": "function", "doc": "<p>Process an event and update the process state.</p>\n\n<p>Handles Start signals to initiate the algorithm, PositionMsg messages\nto learn about other processes and channels, and GraphIsKnown signals.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>old_state:</strong>  The current state of the process.</li>\n<li><strong>event:</strong>  The event to process (Start, PositionMsg, or GraphIsKnown).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A tuple of (new_state, list_of_new_events) to send.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>NotImplementedError:</strong>  If an unknown event type is received.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">old_state</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">algo</span><span class=\"o\">.</span><span class=\"n\">learn</span><span class=\"o\">.</span><span class=\"n\">LearnState</span>,</span><span class=\"param\">\t<span class=\"n\">event</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">Event</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">algo</span><span class=\"o\">.</span><span class=\"n\">learn</span><span class=\"o\">.</span><span class=\"n\">LearnState</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">Event</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core", "modulename": "dapy.core", "kind": "module", "doc": "<p>This module contains the core components of the dapy library, which are used to define\ndistributed algorithms and represent distributed executions.\nThe components are defined in multiple files for better organization and maintainability,\nbut the main ones all re-exported here for convenience.</p>\n\n<p>The core components include:</p>\n\n<ul>\n<li><code>.algorithm</code>:\n<ul>\n<li><code>.algorithm.Algorithm</code>: Abstract base class for defining distributed algorithms.</li>\n</ul></li>\n<li><code>.event</code>:\n<ul>\n<li><code>.event.Event</code>: Abstract class that represents events in the distributed system, including messages and signals.\n<ul>\n<li><code>.event.Signal</code>: Abstract subclass that represents signals occurring at some process.</li>\n<li><code>.event.Message</code>: Abstract subclass that represents messages sent and received between processes.</li>\n</ul></li>\n</ul></li>\n<li><code>.pid</code>:\n<ul>\n<li><code>.pid.Pid</code>: Represents process identifiers (PIDs) in the distributed system.</li>\n<li><code>.pid.ProcessSet</code>: Represents a set of process identities.</li>\n<li><code>.pid.Channel</code>: Represents communication channels between processes.</li>\n<li><code>.pid.ChannelSet</code>: Represents a set of communication channels.</li>\n</ul></li>\n<li><code>.state</code>:\n<ul>\n<li><code>.state.State</code>: Abstract class to define the state of a process in the distributed system.</li>\n</ul></li>\n<li><code>.system</code>:\n<ul>\n<li><code>.system.System</code>: Represents the distributed system model, including its topology and synchrony model.</li>\n<li><code>.system.SynchronyModel</code>: Base class to represents a model of synchrony.\n<ul>\n<li><code>.system.Synchronous</code>: Represents a <strong>synchronous</strong> model (fixed message delays).</li>\n<li><code>.system.Asynchronous</code>: Represents an <strong>asynchronous</strong> model (unpredictable delays).</li>\n<li><code>.system.PartiallySynchronous</code>: Represents a <strong>partially synchronous</strong> model\n(bounded delays after stabilization).</li>\n<li><code>.system.StochasticExponential</code>: Represents a stochastic exponential model where transmission\ndelays follow an exponential distribution.</li>\n</ul></li>\n</ul></li>\n<li><code>.topology</code>:\n<ul>\n<li><code>.topology.NetworkTopology</code>: Represents the topology of the distributed system.\n<ul>\n<li><code>.topology.CompleteGraph</code>: Represents a complete graph topology for the distributed system.</li>\n<li><code>.topology.Ring</code>: Represents a ring topology for the distributed system.</li>\n<li><code>.topology.Star</code>: Represents a star topology for the distributed system.</li>\n<li><code>.topology.ArbitraryGraph</code>: Represents an arbitrary graph topology for the distributed system,\nrepresented by an adjacency list.</li>\n</ul></li>\n</ul></li>\n</ul>\n\n<p>This module is essential for defining distributed algorithms, which is done as follows:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">dataclasses</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">dataclass</span>\n\n<span class=\"c1\"># 1. Import the necessary components from the core module.</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">dapy.core</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Algorithm</span><span class=\"p\">,</span> <span class=\"n\">Event</span><span class=\"p\">,</span> <span class=\"n\">Signal</span><span class=\"p\">,</span> <span class=\"n\">Message</span><span class=\"p\">,</span> <span class=\"n\">Pid</span><span class=\"p\">,</span> <span class=\"n\">State</span>\n\n<span class=\"c1\"># 2. Define a state of a process by subclassing the State class.</span>\n<span class=\"nd\">@dataclass</span><span class=\"p\">(</span><span class=\"n\">frozen</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">MyState</span><span class=\"p\">(</span><span class=\"n\">State</span><span class=\"p\">):</span>\n    <span class=\"n\">some_attribute</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"o\">...</span>\n\n<span class=\"c1\"># 3. Define signal(s) and message(s) by subclassing the relevant class.</span>\n<span class=\"nd\">@dataclass</span><span class=\"p\">(</span><span class=\"n\">frozen</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">MySignal</span><span class=\"p\">(</span><span class=\"n\">Signal</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n<span class=\"nd\">@dataclass</span><span class=\"p\">(</span><span class=\"n\">frozen</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">MyMessage</span><span class=\"p\">(</span><span class=\"n\">Message</span><span class=\"p\">):</span>\n    <span class=\"n\">some_information</span><span class=\"p\">:</span> <span class=\"nb\">str</span>\n\n<span class=\"c1\"># 4. Define the distributed algorithm by subclassing the Algorithm class and providing</span>\n<span class=\"c1\">#    an implementation for the two mandatory abstract methods `initial_state` and `on_event`.</span>\n<span class=\"nd\">@dataclass</span><span class=\"p\">(</span><span class=\"n\">frozen</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">MyAlgorithm</span><span class=\"p\">(</span><span class=\"n\">Algorithm</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">initial_state</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">pid</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">MyState</span><span class=\"p\">:</span>\n        <span class=\"o\">...</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">on_event</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">old_state</span><span class=\"p\">:</span> <span class=\"n\">MyState</span><span class=\"p\">,</span> <span class=\"n\">event</span><span class=\"p\">:</span> <span class=\"n\">Event</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">MyState</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Event</span><span class=\"p\">]]:</span>\n        <span class=\"o\">...</span>\n</code></pre>\n</div>\n\n<p>See the template file and example files for more details on how to define a distributed algorithm using this library.</p>\n"}, {"fullname": "dapy.core.algorithm", "modulename": "dapy.core.algorithm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.core.algorithm.Algorithm", "modulename": "dapy.core.algorithm", "qualname": "Algorithm", "kind": "class", "doc": "<p>Abstract base class for distributed algorithms.</p>\n\n<p>This class defines the interface for distributed algorithms that can be\nsimulated using the dapy framework.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>system:</strong>  The distributed system in which the algorithm is executed.</li>\n</ul>\n", "bases": "abc.ABC"}, {"fullname": "dapy.core.algorithm.Algorithm.system", "modulename": "dapy.core.algorithm", "qualname": "Algorithm.system", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.system.System"}, {"fullname": "dapy.core.algorithm.Algorithm.name", "modulename": "dapy.core.algorithm", "qualname": "Algorithm.name", "kind": "variable", "doc": "<p>Return the name of the algorithm.</p>\n", "annotation": ": str"}, {"fullname": "dapy.core.algorithm.Algorithm.initial_state", "modulename": "dapy.core.algorithm", "qualname": "Algorithm.initial_state", "kind": "function", "doc": "<p>Create the initial state for a process.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pid:</strong>  The process identifier for which to create the initial state.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The initial state for the given process.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">State</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.algorithm.Algorithm.on_start", "modulename": "dapy.core.algorithm", "qualname": "Algorithm.on_start", "kind": "function", "doc": "<p>Handle the start of the algorithm.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">init_state</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">State</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">Event</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.algorithm.Algorithm.on_event", "modulename": "dapy.core.algorithm", "qualname": "Algorithm.on_event", "kind": "function", "doc": "<p>Handle an event.\nGiven the old state and the event, return the new state and a list of events to be sent.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">old_state</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">State</span>,</span><span class=\"param\">\t<span class=\"n\">event</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">Event</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">Event</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.event", "modulename": "dapy.core.event", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.core.event.Event", "modulename": "dapy.core.event", "qualname": "Event", "kind": "class", "doc": "<p>Abstract class to represent an event in the system.</p>\n\n<p>There are two direct subclasses of this class:</p>\n\n<ul>\n<li><code>Signal</code>: represents a signal event (an event that occurs at a single process).</li>\n<li><code>Message</code>: represents a message transmission (an event issued at some process\nand received at a different target process).</li>\n</ul>\n\n<p>This class is not designed to be instantiated directly, but rather\nby subclassing either one of the two subclasses.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>target:</strong>  Pid\nThe process identifier (PID) of the process that the event targets.</li>\n</ul>\n", "bases": "abc.ABC"}, {"fullname": "dapy.core.event.Event.__init__", "modulename": "dapy.core.event", "qualname": "Event.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span>)</span>"}, {"fullname": "dapy.core.event.Event.target", "modulename": "dapy.core.event", "qualname": "Event.target", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.pid.Pid"}, {"fullname": "dapy.core.event.Signal", "modulename": "dapy.core.event", "qualname": "Signal", "kind": "class", "doc": "<p>Class to represent a signal event.</p>\n\n<p>A signal is an event that occurs internally with respect to a process.\nA signal can also be generated externally (with respect to the algorithm)\nand is typically issued at some processes at the initialization of the system.</p>\n\n<p>Signals are defined by creating subclasses of this class.\nThe subclass must be frozen (immutable) and can hold additional\nattributes that are relevant to the signal.</p>\n\n<p>A signal can hold additional information in its attributes, but it is not mandatory.\nTypically, for a given algorithm, it is possible (and encouraged) to define multiple\nsignals, each with an explicit name that makes its purpose clear. This makes it easy\nto discriminate between different signals in the algorithm using structural pattern\nmatching (<code>match</code> statement).</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>target:</strong>  Pid\nThe process identifier (PID) of the process that the signal targets.</li>\n</ul>\n", "bases": "Event"}, {"fullname": "dapy.core.event.Signal.__init__", "modulename": "dapy.core.event", "qualname": "Signal.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span>)</span>"}, {"fullname": "dapy.core.event.Message", "modulename": "dapy.core.event", "qualname": "Message", "kind": "class", "doc": "<p>Class to represent a send/receive event.</p>\n\n<p>A message is an event that occurs between two processes.\nThe sender and the receiver (target) are both specified.</p>\n\n<p>Messages are defined by creating subclasses of this class.\nThe subclass must be frozen (immutable) and can hold additional\nattributes that are relevant to the message.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>target:</strong>  Pid\nThe process identifier (PID) of the process that __receives__ the message (i.e, that the message targets).</li>\n<li><strong>sender:</strong>  Pid\nThe process identifier (PID) of the process that __sends__ the message.</li>\n</ul>\n", "bases": "Event"}, {"fullname": "dapy.core.event.Message.__init__", "modulename": "dapy.core.event", "qualname": "Message.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>, </span><span class=\"param\"><span class=\"n\">sender</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span>)</span>"}, {"fullname": "dapy.core.event.Message.sender", "modulename": "dapy.core.event", "qualname": "Message.sender", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.pid.Pid"}, {"fullname": "dapy.core.pid", "modulename": "dapy.core.pid", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.core.pid.Pid", "modulename": "dapy.core.pid", "qualname": "Pid", "kind": "class", "doc": "<p>Represents a unique process identifier in a distributed system.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>id:</strong>  The unique numeric identifier for the process.</li>\n</ul>\n"}, {"fullname": "dapy.core.pid.Pid.__init__", "modulename": "dapy.core.pid", "qualname": "Pid.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "dapy.core.pid.Pid.id", "modulename": "dapy.core.pid", "qualname": "Pid.id", "kind": "variable", "doc": "<p></p>\n", "annotation": ": int"}, {"fullname": "dapy.core.pid.ProcessSet", "modulename": "dapy.core.pid", "qualname": "ProcessSet", "kind": "class", "doc": "<p>Represents an immutable set of process identifiers.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>processes:</strong>  A frozenset of unique process identifiers.</li>\n</ul>\n"}, {"fullname": "dapy.core.pid.ProcessSet.__init__", "modulename": "dapy.core.pid", "qualname": "ProcessSet.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">processes</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">],</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">frozenset</span><span class=\"p\">()</span></span>)</span>"}, {"fullname": "dapy.core.pid.ProcessSet.processes", "modulename": "dapy.core.pid", "qualname": "ProcessSet.processes", "kind": "variable", "doc": "<p></p>\n", "annotation": ": frozenset[dapy.core.pid.Pid]"}, {"fullname": "dapy.core.pid.ProcessSet.empty", "modulename": "dapy.core.pid", "qualname": "ProcessSet.empty", "kind": "function", "doc": "<p>Create an empty process set.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>An empty ProcessSet instance.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.pid.Channel", "modulename": "dapy.core.pid", "qualname": "Channel", "kind": "class", "doc": "<p>Represents a communication channel between two processes.</p>\n\n<p>Channels can be directed (sender to receiver) or undirected.\nFor undirected channels, the order of processes is normalized for equality.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>s:</strong>  The sender process identifier.</li>\n<li><strong>r:</strong>  The receiver process identifier.</li>\n<li><strong>directed:</strong>  Indicates if the channel is directed. Defaults to True.</li>\n</ul>\n"}, {"fullname": "dapy.core.pid.Channel.__init__", "modulename": "dapy.core.pid", "qualname": "Channel.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>, </span><span class=\"param\"><span class=\"n\">r</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>, </span><span class=\"param\"><span class=\"n\">directed</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "dapy.core.pid.Channel.s", "modulename": "dapy.core.pid", "qualname": "Channel.s", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.pid.Pid"}, {"fullname": "dapy.core.pid.Channel.r", "modulename": "dapy.core.pid", "qualname": "Channel.r", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.pid.Pid"}, {"fullname": "dapy.core.pid.Channel.directed", "modulename": "dapy.core.pid", "qualname": "Channel.directed", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "True"}, {"fullname": "dapy.core.pid.Channel.as_tuple", "modulename": "dapy.core.pid", "qualname": "Channel.as_tuple", "kind": "function", "doc": "<p>Convert the channel to a tuple of process identifiers.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A tuple (sender, receiver) representing the channel.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">,</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.pid.Channel.normalized", "modulename": "dapy.core.pid", "qualname": "Channel.normalized", "kind": "function", "doc": "<p>Return a normalized representation of the channel for comparison.</p>\n\n<p>For undirected channels, ensures the smaller PID comes first.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A tuple where the first PID is always less than or equal to the second.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">,</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.pid.ChannelSet", "modulename": "dapy.core.pid", "qualname": "ChannelSet", "kind": "class", "doc": "<p>Represents an immutable set of communication channels.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>channels:</strong>  A frozenset of unique Channel objects.</li>\n</ul>\n"}, {"fullname": "dapy.core.pid.ChannelSet.__init__", "modulename": "dapy.core.pid", "qualname": "ChannelSet.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">channels</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Channel</span><span class=\"p\">],</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Channel</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">frozenset</span><span class=\"p\">()</span></span>)</span>"}, {"fullname": "dapy.core.pid.ChannelSet.channels", "modulename": "dapy.core.pid", "qualname": "ChannelSet.channels", "kind": "variable", "doc": "<p></p>\n", "annotation": ": frozenset[dapy.core.pid.Channel]"}, {"fullname": "dapy.core.state", "modulename": "dapy.core.state", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.core.state.State", "modulename": "dapy.core.state", "qualname": "State", "kind": "class", "doc": "<p>Abstract class to represent the state of an algorithm.</p>\n", "bases": "abc.ABC"}, {"fullname": "dapy.core.state.State.__init__", "modulename": "dapy.core.state", "qualname": "State.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span>)</span>"}, {"fullname": "dapy.core.state.State.pid", "modulename": "dapy.core.state", "qualname": "State.pid", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.pid.Pid"}, {"fullname": "dapy.core.state.State.cloned_with", "modulename": "dapy.core.state", "qualname": "State.cloned_with", "kind": "function", "doc": "<p>Create a copy of this state with updated attributes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>**kwargs:</strong>  Attribute name-value pairs to update in the cloned state.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new State instance with the specified attributes updated.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.state.State.as_str", "modulename": "dapy.core.state", "qualname": "State.as_str", "kind": "function", "doc": "<p>Get a formatted string representation of the state.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>keys:</strong>  An optional list of attribute keys to include in the string.\nIf None, all attributes are included except 'pid'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A formatted string representation showing pid and selected attributes.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">keys</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.system", "modulename": "dapy.core.system", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.core.system.SynchronyModel", "modulename": "dapy.core.system", "qualname": "SynchronyModel", "kind": "class", "doc": "<p></p>\n", "bases": "abc.ABC"}, {"fullname": "dapy.core.system.SynchronyModel.min_delay", "modulename": "dapy.core.system", "qualname": "SynchronyModel.min_delay", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.timedelta", "default_value": "datetime.timedelta(microseconds=1)"}, {"fullname": "dapy.core.system.SynchronyModel.arrival_time_for", "modulename": "dapy.core.system", "qualname": "SynchronyModel.arrival_time_for", "kind": "function", "doc": "<p>Calculate the arrival time for a message based on the synchrony model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sent_at:</strong>  The time when the message is sent.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The time when the message should arrive.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">sent_at</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">time</span></span><span class=\"return-annotation\">) -> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">time</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.system.Synchronous", "modulename": "dapy.core.system", "qualname": "Synchronous", "kind": "class", "doc": "<p>Represents a synchronous system with bounded communication delays.</p>\n\n<p>In a synchronous system, all communication is bounded by a fixed time interval.\nMessages are guaranteed to arrive within this fixed delay.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>fixed_delay:</strong>  The maximum delay for all message deliveries. Defaults to 1 millisecond.</li>\n</ul>\n", "bases": "SynchronyModel"}, {"fullname": "dapy.core.system.Synchronous.__init__", "modulename": "dapy.core.system", "qualname": "Synchronous.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">min_delay</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span> <span class=\"o\">=</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">microseconds</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">fixed_delay</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span> <span class=\"o\">=</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">microseconds</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">)</span></span>)</span>"}, {"fullname": "dapy.core.system.Synchronous.fixed_delay", "modulename": "dapy.core.system", "qualname": "Synchronous.fixed_delay", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.timedelta", "default_value": "datetime.timedelta(microseconds=1000)"}, {"fullname": "dapy.core.system.Synchronous.arrival_time_for", "modulename": "dapy.core.system", "qualname": "Synchronous.arrival_time_for", "kind": "function", "doc": "<p>Calculate the arrival time for a message based on the synchrony model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sent_at:</strong>  The time when the message is sent.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The time when the message should arrive.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">sent_at</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">time</span></span><span class=\"return-annotation\">) -> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">time</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.system.Asynchronous", "modulename": "dapy.core.system", "qualname": "Asynchronous", "kind": "class", "doc": "<p>Represents an asynchronous system with unbounded communication delays.</p>\n\n<p>In an asynchronous system, there are no bounds on message delivery times.\nMessages may be delayed arbitrarily but are eventually delivered.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>base_delay:</strong>  The base delay for message deliveries. Defaults to 1 second.</li>\n</ul>\n", "bases": "SynchronyModel"}, {"fullname": "dapy.core.system.Asynchronous.__init__", "modulename": "dapy.core.system", "qualname": "Asynchronous.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">min_delay</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span> <span class=\"o\">=</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">microseconds</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">base_delay</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span> <span class=\"o\">=</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">seconds</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span></span>)</span>"}, {"fullname": "dapy.core.system.Asynchronous.base_delay", "modulename": "dapy.core.system", "qualname": "Asynchronous.base_delay", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.timedelta", "default_value": "datetime.timedelta(seconds=1)"}, {"fullname": "dapy.core.system.Asynchronous.arrival_time_for", "modulename": "dapy.core.system", "qualname": "Asynchronous.arrival_time_for", "kind": "function", "doc": "<p>Calculate the arrival time for a message based on the synchrony model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sent_at:</strong>  The time when the message is sent.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The time when the message should arrive.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">sent_at</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">time</span></span><span class=\"return-annotation\">) -> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">time</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.system.PartiallySynchronous", "modulename": "dapy.core.system", "qualname": "PartiallySynchronous", "kind": "class", "doc": "<p>Represents a partially synchronous system with eventual synchrony bounds.</p>\n\n<p>In a partially synchronous system, communication is eventually bounded after a\nglobal synchronization time (GST). Before GST, messages may experience\nunbounded delays; after GST, message delivery is bounded.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>gst:</strong>  The global synchronization time after which message bounds apply.</li>\n</ul>\n", "bases": "Synchronous"}, {"fullname": "dapy.core.system.PartiallySynchronous.__init__", "modulename": "dapy.core.system", "qualname": "PartiallySynchronous.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">min_delay</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span> <span class=\"o\">=</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">microseconds</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">fixed_delay</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span> <span class=\"o\">=</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">microseconds</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">gst</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">time</span></span>)</span>"}, {"fullname": "dapy.core.system.PartiallySynchronous.gst", "modulename": "dapy.core.system", "qualname": "PartiallySynchronous.gst", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.time"}, {"fullname": "dapy.core.system.PartiallySynchronous.arrival_time_for", "modulename": "dapy.core.system", "qualname": "PartiallySynchronous.arrival_time_for", "kind": "function", "doc": "<p>Calculate the arrival time for a message based on the synchrony model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sent_at:</strong>  The time when the message is sent.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The time when the message should arrive.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">sent_at</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">time</span></span><span class=\"return-annotation\">) -> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">time</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.system.StochasticExponential", "modulename": "dapy.core.system", "qualname": "StochasticExponential", "kind": "class", "doc": "<p>Represents a stochastic system with exponentially distributed delays.</p>\n\n<p>In a stochastic system, message delivery times follow an exponential distribution.\nThis models realistic network behavior with occasional long delays.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>delta_t:</strong>  The time scale parameter for the exponential distribution.\nDefaults to 1 millisecond.</li>\n</ul>\n", "bases": "SynchronyModel"}, {"fullname": "dapy.core.system.StochasticExponential.__init__", "modulename": "dapy.core.system", "qualname": "StochasticExponential.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">min_delay</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span> <span class=\"o\">=</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">microseconds</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">delta_t</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span> <span class=\"o\">=</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">microseconds</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">)</span></span>)</span>"}, {"fullname": "dapy.core.system.StochasticExponential.delta_t", "modulename": "dapy.core.system", "qualname": "StochasticExponential.delta_t", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.timedelta", "default_value": "datetime.timedelta(microseconds=1000)"}, {"fullname": "dapy.core.system.StochasticExponential.arrival_time_for", "modulename": "dapy.core.system", "qualname": "StochasticExponential.arrival_time_for", "kind": "function", "doc": "<p>Calculate the arrival time for a message based on the synchrony model.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sent_at:</strong>  The time when the message is sent.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The time when the message should arrive.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">sent_at</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">time</span></span><span class=\"return-annotation\">) -> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">time</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.system.System", "modulename": "dapy.core.system", "qualname": "System", "kind": "class", "doc": "<p>Represents a distributed system with topology and synchrony model.</p>\n\n<p>A system combines a network topology (defining process connections) with a\nsynchrony model (defining communication constraints).</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>topology:</strong>  The network topology defining process connections.</li>\n<li><strong>synchrony:</strong>  The synchrony model defining communication constraints.\nDefaults to Asynchronous.</li>\n</ul>\n"}, {"fullname": "dapy.core.system.System.__init__", "modulename": "dapy.core.system", "qualname": "System.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">topology</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">topology</span><span class=\"o\">.</span><span class=\"n\">NetworkTopology</span>,</span><span class=\"param\">\t<span class=\"n\">synchrony</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">SynchronyModel</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "dapy.core.system.System.topology", "modulename": "dapy.core.system", "qualname": "System.topology", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.topology.NetworkTopology"}, {"fullname": "dapy.core.system.System.synchrony", "modulename": "dapy.core.system", "qualname": "System.synchrony", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.system.SynchronyModel"}, {"fullname": "dapy.core.system.System.processes", "modulename": "dapy.core.system", "qualname": "System.processes", "kind": "function", "doc": "<p>Get all processes in the system.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>An iterable of all process identifiers in the system.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.system.System.neighbors_of", "modulename": "dapy.core.system", "qualname": "System.neighbors_of", "kind": "function", "doc": "<p>Get the neighboring processes of a given process.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pid:</strong>  The identifier of the process.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The set of process identifiers that are neighbors of the given process.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology", "modulename": "dapy.core.topology", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.core.topology.NetworkTopology", "modulename": "dapy.core.topology", "qualname": "NetworkTopology", "kind": "class", "doc": "<p>Abstract class to represent a network topology.</p>\n", "bases": "abc.ABC"}, {"fullname": "dapy.core.topology.NetworkTopology.neighbors_of", "modulename": "dapy.core.topology", "qualname": "NetworkTopology.neighbors_of", "kind": "function", "doc": "<p>Get the neighbors of the given process in the topology.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pid:</strong>  The process identifier.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A ProcessSet containing all neighbors of the given process.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.NetworkTopology.processes", "modulename": "dapy.core.topology", "qualname": "NetworkTopology.processes", "kind": "function", "doc": "<p>Return the set of all processes in the topology.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A ProcessSet containing all processes in this topology.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.CompleteGraph", "modulename": "dapy.core.topology", "qualname": "CompleteGraph", "kind": "class", "doc": "<p></p>\n", "bases": "NetworkTopology"}, {"fullname": "dapy.core.topology.CompleteGraph.__init__", "modulename": "dapy.core.topology", "qualname": "CompleteGraph.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">_processes</span><span class=\"p\">:</span> <span class=\"nb\">frozenset</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "dapy.core.topology.CompleteGraph.neighbors_of", "modulename": "dapy.core.topology", "qualname": "CompleteGraph.neighbors_of", "kind": "function", "doc": "<p>Get the neighbors of the given process in the topology.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pid:</strong>  The process identifier.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A ProcessSet containing all neighbors of the given process.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.CompleteGraph.processes", "modulename": "dapy.core.topology", "qualname": "CompleteGraph.processes", "kind": "function", "doc": "<p>Return the set of all processes in the topology.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A ProcessSet containing all processes in this topology.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.CompleteGraph.from_", "modulename": "dapy.core.topology", "qualname": "CompleteGraph.from_", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">processes</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.CompleteGraph.of_size", "modulename": "dapy.core.topology", "qualname": "CompleteGraph.of_size", "kind": "function", "doc": "<p>Create a complete graph topology with the given number of processes.</p>\n\n<p>In a complete graph, every process is connected to every other process.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>size:</strong>  The number of processes in the topology. Must be positive.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A CompleteGraph instance with sequential process IDs from 1 to size.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>ValueError:</strong>  If size is not a positive integer.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Ring", "modulename": "dapy.core.topology", "qualname": "Ring", "kind": "class", "doc": "<p></p>\n", "bases": "NetworkTopology"}, {"fullname": "dapy.core.topology.Ring.__init__", "modulename": "dapy.core.topology", "qualname": "Ring.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">_processes</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">_index</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">directed</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "dapy.core.topology.Ring.directed", "modulename": "dapy.core.topology", "qualname": "Ring.directed", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "dapy.core.topology.Ring.neighbors_of", "modulename": "dapy.core.topology", "qualname": "Ring.neighbors_of", "kind": "function", "doc": "<p>Get the neighbors of the given process in the topology.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pid:</strong>  The process identifier.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A ProcessSet containing all neighbors of the given process.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Ring.processes", "modulename": "dapy.core.topology", "qualname": "Ring.processes", "kind": "function", "doc": "<p>Return the set of all processes in the topology.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A ProcessSet containing all processes in this topology.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Ring.from_", "modulename": "dapy.core.topology", "qualname": "Ring.from_", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">processes</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">directed</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Ring.of_size", "modulename": "dapy.core.topology", "qualname": "Ring.of_size", "kind": "function", "doc": "<p>Create a ring topology with the given size.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">directed</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Star", "modulename": "dapy.core.topology", "qualname": "Star", "kind": "class", "doc": "<p></p>\n", "bases": "NetworkTopology"}, {"fullname": "dapy.core.topology.Star.__init__", "modulename": "dapy.core.topology", "qualname": "Star.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">_center</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>, </span><span class=\"param\"><span class=\"n\">_leaves</span><span class=\"p\">:</span> <span class=\"nb\">frozenset</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "dapy.core.topology.Star.center", "modulename": "dapy.core.topology", "qualname": "Star.center", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Star.neighbors_of", "modulename": "dapy.core.topology", "qualname": "Star.neighbors_of", "kind": "function", "doc": "<p>Get the neighbors of the given process in the topology.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pid:</strong>  The process identifier.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A ProcessSet containing all neighbors of the given process.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Star.processes", "modulename": "dapy.core.topology", "qualname": "Star.processes", "kind": "function", "doc": "<p>Return the set of all processes in the topology.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A ProcessSet containing all processes in this topology.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Star.from_", "modulename": "dapy.core.topology", "qualname": "Star.from_", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">center</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>,</span><span class=\"param\">\t<span class=\"n\">leaves</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Star.of_size", "modulename": "dapy.core.topology", "qualname": "Star.of_size", "kind": "function", "doc": "<p>Create a star topology with the given size.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Arbitrary", "modulename": "dapy.core.topology", "qualname": "Arbitrary", "kind": "class", "doc": "<p></p>\n", "bases": "NetworkTopology"}, {"fullname": "dapy.core.topology.Arbitrary.__init__", "modulename": "dapy.core.topology", "qualname": "Arbitrary.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">_neighbors</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">,</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "dapy.core.topology.Arbitrary.neighbors_of", "modulename": "dapy.core.topology", "qualname": "Arbitrary.neighbors_of", "kind": "function", "doc": "<p>Get the neighbors of the given process in the topology.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pid:</strong>  The process identifier.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A ProcessSet containing all neighbors of the given process.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pid</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Arbitrary.processes", "modulename": "dapy.core.topology", "qualname": "Arbitrary.processes", "kind": "function", "doc": "<p>Return the set of all processes in the topology.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A ProcessSet containing all processes in this topology.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">ProcessSet</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.core.topology.Arbitrary.from_", "modulename": "dapy.core.topology", "qualname": "Arbitrary.from_", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">channels</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span> <span class=\"o\">|</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">,</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Channel</span> <span class=\"o\">|</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">directed</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim", "modulename": "dapy.sim", "kind": "module", "doc": "<p>dapy.sim</p>\n\n<p>This module defines the runtime environment for simulating distributed algorithms.</p>\n\n<p>The main components of this module include:</p>\n\n<ul>\n<li><code>.simulator.Simulator</code>: The main class that runs a simulation according to a given system model and an algorithm.</li>\n<li><code>.configuration.Configuration</code>: Represents the state of a system. This is a collection of the state of each process.</li>\n<li><code>.trace.Trace</code>: When tracing is enabled, this class stores the entire history of the simulation.</li>\n</ul>\n\n<p>In addition, the module provides a set of utility classes and functions to facilitate the simulation process, including:</p>\n\n<ul>\n<li><code>.settings.Settings</code>: Configuration settings for the simulation.</li>\n<li><code>.timed.TimedEvent</code>: Represents an event associated with a scheduled time.</li>\n<li><code>.timed.TimedConfiguration</code>: Represents a configuration with a creation time.</li>\n</ul>\n"}, {"fullname": "dapy.sim.configuration", "modulename": "dapy.sim.configuration", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.sim.configuration.Configuration", "modulename": "dapy.sim.configuration", "qualname": "Configuration", "kind": "class", "doc": "<p>Represents the state of all processes in a distributed system at a given time.</p>\n\n<p>A configuration maps each process identifier (PID) to its current state.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>states:</strong>  A dictionary mapping process identifiers to their current states.</li>\n</ul>\n"}, {"fullname": "dapy.sim.configuration.Configuration.__init__", "modulename": "dapy.sim.configuration", "qualname": "Configuration.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">states</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">,</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "dapy.sim.configuration.Configuration.states", "modulename": "dapy.sim.configuration", "qualname": "Configuration.states", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict[dapy.core.pid.Pid, dapy.core.state.State]"}, {"fullname": "dapy.sim.configuration.Configuration.updated", "modulename": "dapy.sim.configuration", "qualname": "Configuration.updated", "kind": "function", "doc": "<p>Create a new configuration with updated states.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>states:</strong>  An iterable of new states that should replace the old ones.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new Configuration with the updated states.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">states</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.configuration.Configuration.processes", "modulename": "dapy.sim.configuration", "qualname": "Configuration.processes", "kind": "function", "doc": "<p>Get the identifiers of all processes in the configuration.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>An iterable of process identifiers, sorted in ascending order.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.configuration.Configuration.changed_from", "modulename": "dapy.sim.configuration", "qualname": "Configuration.changed_from", "kind": "function", "doc": "<p>Get the identifiers of processes that have changed between two configurations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>other:</strong>  The previous configuration to compare against.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>An iterable of process identifiers whose states have changed.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"n\">Self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.configuration.Configuration.from_states", "modulename": "dapy.sim.configuration", "qualname": "Configuration.from_states", "kind": "function", "doc": "<p>Create a configuration from a collection of process states.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>states:</strong>  An iterable of State objects with associated process identifiers.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new Configuration mapping each process to its state.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">states</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">State</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.settings", "modulename": "dapy.sim.settings", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.sim.settings.Settings", "modulename": "dapy.sim.settings", "qualname": "Settings", "kind": "class", "doc": "<p>Configuration settings for a simulation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>is_verbose:</strong>  Enable verbose output during simulation. Defaults to False.</li>\n<li><strong>is_debug:</strong>  Enable debug mode for detailed logging. Defaults to False.</li>\n<li><strong>enable_trace:</strong>  Enable trace recording for the simulation. Defaults to False.</li>\n</ul>\n"}, {"fullname": "dapy.sim.settings.Settings.__init__", "modulename": "dapy.sim.settings", "qualname": "Settings.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">is_verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">is_debug</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">enable_trace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "dapy.sim.settings.Settings.is_verbose", "modulename": "dapy.sim.settings", "qualname": "Settings.is_verbose", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "dapy.sim.settings.Settings.is_debug", "modulename": "dapy.sim.settings", "qualname": "Settings.is_debug", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "dapy.sim.settings.Settings.enable_trace", "modulename": "dapy.sim.settings", "qualname": "Settings.enable_trace", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": "False"}, {"fullname": "dapy.sim.simulator", "modulename": "dapy.sim.simulator", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.sim.simulator.Simulator", "modulename": "dapy.sim.simulator", "qualname": "Simulator", "kind": "class", "doc": "<p>Simulates the execution of a distributed algorithm on a system.</p>\n\n<p>The simulator manages the execution of a distributed algorithm by processing\nevents (messages and signals) in chronological order on a system with a\nspecific synchrony model.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>system:</strong>  The distributed system to simulate (topology and synchrony model).</li>\n<li><strong>algorithm:</strong>  The distributed algorithm to execute.</li>\n<li><strong>current_configuration:</strong>  The current state of all processes.</li>\n<li><strong>current_time:</strong>  The current simulation time. Defaults to 0 seconds.</li>\n<li><strong>settings:</strong>  Configuration settings for the simulation. Defaults to default Settings.</li>\n<li><strong>trace:</strong>  Optional trace object for recording simulation events.</li>\n<li><strong>scheduled_events:</strong>  Priority queue of events waiting to be processed.</li>\n</ul>\n"}, {"fullname": "dapy.sim.simulator.Simulator.__init__", "modulename": "dapy.sim.simulator", "qualname": "Simulator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>,</span><span class=\"param\">\t<span class=\"n\">algorithm</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">algorithm</span><span class=\"o\">.</span><span class=\"n\">Algorithm</span>,</span><span class=\"param\">\t<span class=\"n\">current_configuration</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span>,</span><span class=\"param\">\t<span class=\"n\">current_time</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span> <span class=\"o\">=</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">settings</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">settings</span><span class=\"o\">.</span><span class=\"n\">Settings</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">trace</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">trace</span><span class=\"o\">.</span><span class=\"n\">Trace</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "dapy.sim.simulator.Simulator.system", "modulename": "dapy.sim.simulator", "qualname": "Simulator.system", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.system.System"}, {"fullname": "dapy.sim.simulator.Simulator.algorithm", "modulename": "dapy.sim.simulator", "qualname": "Simulator.algorithm", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.algorithm.Algorithm"}, {"fullname": "dapy.sim.simulator.Simulator.current_configuration", "modulename": "dapy.sim.simulator", "qualname": "Simulator.current_configuration", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.sim.configuration.Configuration"}, {"fullname": "dapy.sim.simulator.Simulator.current_time", "modulename": "dapy.sim.simulator", "qualname": "Simulator.current_time", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.timedelta", "default_value": "datetime.timedelta(0)"}, {"fullname": "dapy.sim.simulator.Simulator.settings", "modulename": "dapy.sim.simulator", "qualname": "Simulator.settings", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.sim.settings.Settings"}, {"fullname": "dapy.sim.simulator.Simulator.trace", "modulename": "dapy.sim.simulator", "qualname": "Simulator.trace", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Optional[dapy.sim.trace.Trace]", "default_value": "None"}, {"fullname": "dapy.sim.simulator.Simulator.scheduled_events", "modulename": "dapy.sim.simulator", "qualname": "Simulator.scheduled_events", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[dapy.sim.timed.TimedEvent]"}, {"fullname": "dapy.sim.simulator.Simulator.from_system", "modulename": "dapy.sim.simulator", "qualname": "Simulator.from_system", "kind": "function", "doc": "<p>Create a simulator instance from a system and algorithm.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>system:</strong>  The distributed system to simulate.</li>\n<li><strong>algorithm:</strong>  The distributed algorithm to execute.</li>\n<li><strong>starting_time:</strong>  The initial simulation time. Defaults to 0 seconds.</li>\n<li><strong>settings:</strong>  Configuration settings for the simulation.\nDefaults to default Settings.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A new Simulator instance initialized with the given system and algorithm.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>,</span><span class=\"param\">\t<span class=\"n\">algorithm</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">algorithm</span><span class=\"o\">.</span><span class=\"n\">Algorithm</span>,</span><span class=\"param\">\t<span class=\"n\">starting_time</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span> <span class=\"o\">=</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">settings</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">settings</span><span class=\"o\">.</span><span class=\"n\">Settings</span> <span class=\"o\">=</span> <span class=\"n\">Settings</span><span class=\"p\">(</span><span class=\"n\">is_verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">is_debug</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">enable_trace</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.simulator.Simulator.start", "modulename": "dapy.sim.simulator", "qualname": "Simulator.start", "kind": "function", "doc": "<p>Initialize and start the simulation.</p>\n\n<p>Resets the simulation time to 0 and invokes the algorithm's on_start\nhandler for each process to generate initial events.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.simulator.Simulator.schedule_event", "modulename": "dapy.sim.simulator", "qualname": "Simulator.schedule_event", "kind": "function", "doc": "<p>Schedule an event to be processed at a specific time.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>at:</strong>  The time when the event should be processed.</li>\n<li><strong>event:</strong>  The event to schedule.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">at</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span>, </span><span class=\"param\"><span class=\"n\">event</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">Event</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.simulator.Simulator.advance_step", "modulename": "dapy.sim.simulator", "qualname": "Simulator.advance_step", "kind": "function", "doc": "<p>Advance the simulation by processing one scheduled event.</p>\n\n<p>Pops the earliest scheduled event from the priority queue and applies\nit to the current configuration, updating the simulation time.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.simulator.Simulator.run_to_completion", "modulename": "dapy.sim.simulator", "qualname": "Simulator.run_to_completion", "kind": "function", "doc": "<p>Run the simulation until completion or until a step limit is reached.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>step_limit:</strong>  Maximum number of steps to execute. If None, runs until\nno more events are scheduled. Defaults to None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">step_limit</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.simulator.Simulator.is_finished", "modulename": "dapy.sim.simulator", "qualname": "Simulator.is_finished", "kind": "function", "doc": "<p>Check if the simulation has finished.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if there are no more scheduled events, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.timed", "modulename": "dapy.sim.timed", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.sim.timed.Timed", "modulename": "dapy.sim.timed", "qualname": "Timed", "kind": "class", "doc": "<p>Abstract base class for objects with an associated timestamp.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>time:</strong>  The timestamp associated with this object.</li>\n</ul>\n", "bases": "abc.ABC"}, {"fullname": "dapy.sim.timed.Timed.__init__", "modulename": "dapy.sim.timed", "qualname": "Timed.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span></span>)</span>"}, {"fullname": "dapy.sim.timed.Timed.time", "modulename": "dapy.sim.timed", "qualname": "Timed.time", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.timedelta"}, {"fullname": "dapy.sim.timed.TimedEvent", "modulename": "dapy.sim.timed", "qualname": "TimedEvent", "kind": "class", "doc": "<p>Represents an event associated with a specific time.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>time:</strong>  The time when the event occurs.</li>\n<li><strong>event:</strong>  The event object.</li>\n</ul>\n", "bases": "Timed"}, {"fullname": "dapy.sim.timed.TimedEvent.__init__", "modulename": "dapy.sim.timed", "qualname": "TimedEvent.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span>, </span><span class=\"param\"><span class=\"n\">event</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">Event</span></span>)</span>"}, {"fullname": "dapy.sim.timed.TimedEvent.event", "modulename": "dapy.sim.timed", "qualname": "TimedEvent.event", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.event.Event"}, {"fullname": "dapy.sim.timed.TimedConfiguration", "modulename": "dapy.sim.timed", "qualname": "TimedConfiguration", "kind": "class", "doc": "<p>Represents a system configuration at a specific time.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>time:</strong>  The time when this configuration was active.</li>\n<li><strong>configuration:</strong>  The configuration object.</li>\n</ul>\n", "bases": "Timed"}, {"fullname": "dapy.sim.timed.TimedConfiguration.__init__", "modulename": "dapy.sim.timed", "qualname": "TimedConfiguration.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">time</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span>,</span><span class=\"param\">\t<span class=\"n\">configuration</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span></span>)</span>"}, {"fullname": "dapy.sim.timed.TimedConfiguration.configuration", "modulename": "dapy.sim.timed", "qualname": "TimedConfiguration.configuration", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.sim.configuration.Configuration"}, {"fullname": "dapy.sim.trace", "modulename": "dapy.sim.trace", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "dapy.sim.trace.LocalTimedEvent", "modulename": "dapy.sim.trace", "qualname": "LocalTimedEvent", "kind": "class", "doc": "<p>Represents a timed event with transmission interval during simulation.</p>\n\n<p>Records the start time when an event is sent and the end time when it arrives,\nuseful for understanding message delays in the simulation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>start:</strong>  The time when the event was sent.</li>\n<li><strong>end:</strong>  The time when the event arrived at its destination.</li>\n<li><strong>event:</strong>  The event object (Message or Signal).</li>\n</ul>\n"}, {"fullname": "dapy.sim.trace.LocalTimedEvent.__init__", "modulename": "dapy.sim.trace", "qualname": "LocalTimedEvent.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span>,</span><span class=\"param\">\t<span class=\"n\">end</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span>,</span><span class=\"param\">\t<span class=\"n\">event</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">Event</span></span>)</span>"}, {"fullname": "dapy.sim.trace.LocalTimedEvent.start", "modulename": "dapy.sim.trace", "qualname": "LocalTimedEvent.start", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.timedelta"}, {"fullname": "dapy.sim.trace.LocalTimedEvent.end", "modulename": "dapy.sim.trace", "qualname": "LocalTimedEvent.end", "kind": "variable", "doc": "<p></p>\n", "annotation": ": datetime.timedelta"}, {"fullname": "dapy.sim.trace.LocalTimedEvent.event", "modulename": "dapy.sim.trace", "qualname": "LocalTimedEvent.event", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.event.Event"}, {"fullname": "dapy.sim.trace.LocalTimedEvent.is_message", "modulename": "dapy.sim.trace", "qualname": "LocalTimedEvent.is_message", "kind": "function", "doc": "<p>Check if this timed event represents a message transmission.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if the event is a Message, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.trace.LocalTimedEvent.is_signal", "modulename": "dapy.sim.trace", "qualname": "LocalTimedEvent.is_signal", "kind": "function", "doc": "<p>Check if this timed event represents a signal.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>True if the event is a Signal, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.trace.LocalTimedEvent.sender", "modulename": "dapy.sim.trace", "qualname": "LocalTimedEvent.sender", "kind": "function", "doc": "<p>Get the sender/initiator of this event.</p>\n\n<p>For messages, returns the sender. For signals, returns the target.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The process identifier of the event's sender/initiator.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.trace.LocalTimedEvent.receiver", "modulename": "dapy.sim.trace", "qualname": "LocalTimedEvent.receiver", "kind": "function", "doc": "<p>Get the receiver of this event.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The process identifier of the event's target/receiver.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">pid</span><span class=\"o\">.</span><span class=\"n\">Pid</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.trace.Trace", "modulename": "dapy.sim.trace", "qualname": "Trace", "kind": "class", "doc": "<p>Represents the execution trace of a distributed algorithm simulation.</p>\n\n<p>A trace records both the events (messages and signals) exchanged between\nprocesses and the system configurations at various time points during\nthe simulation.</p>\n\n<h6 id=\"attributes\">Attributes:</h6>\n\n<ul>\n<li><strong>system:</strong>  The distributed system being simulated.</li>\n<li><strong>algorithm_name:</strong>  The name of the algorithm being executed.</li>\n<li><strong>history:</strong>  List of system configurations at specific time points.</li>\n<li><strong>events_list:</strong>  List of timed events during the simulation.</li>\n</ul>\n"}, {"fullname": "dapy.sim.trace.Trace.__init__", "modulename": "dapy.sim.trace", "qualname": "Trace.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>,</span><span class=\"param\">\t<span class=\"n\">algorithm_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">history</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">timed</span><span class=\"o\">.</span><span class=\"n\">TimedConfiguration</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">events_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">trace</span><span class=\"o\">.</span><span class=\"n\">LocalTimedEvent</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">factory</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "dapy.sim.trace.Trace.system", "modulename": "dapy.sim.trace", "qualname": "Trace.system", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dapy.core.system.System"}, {"fullname": "dapy.sim.trace.Trace.algorithm_name", "modulename": "dapy.sim.trace", "qualname": "Trace.algorithm_name", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "dapy.sim.trace.Trace.history", "modulename": "dapy.sim.trace", "qualname": "Trace.history", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[dapy.sim.timed.TimedConfiguration]"}, {"fullname": "dapy.sim.trace.Trace.events_list", "modulename": "dapy.sim.trace", "qualname": "Trace.events_list", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list[dapy.sim.trace.LocalTimedEvent]"}, {"fullname": "dapy.sim.trace.Trace.add_events", "modulename": "dapy.sim.trace", "qualname": "Trace.add_events", "kind": "function", "doc": "<p>Add timed events to the trace.</p>\n\n<p>Message events require two timestamps: one for the send time at the sender\nand one for the arrival time at the receiver.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>events:</strong>  An iterable of (start_time, end_time, event) tuples where\nstart_time is when the event begins and end_time is when it completes.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">events</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">,</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">Event</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.trace.Trace.add_history", "modulename": "dapy.sim.trace", "qualname": "Trace.add_history", "kind": "function", "doc": "<p>Add system configurations at specific time points to the trace.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>history:</strong>  An iterable of (time, configuration) tuples representing\nthe system state at each time point.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">history</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">,</span> <span class=\"n\">dapy</span><span class=\"o\">.</span><span class=\"n\">sim</span><span class=\"o\">.</span><span class=\"n\">configuration</span><span class=\"o\">.</span><span class=\"n\">Configuration</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.trace.Trace.dump_pickle", "modulename": "dapy.sim.trace", "qualname": "Trace.dump_pickle", "kind": "function", "doc": "<p>Serialize the trace to a pickle byte string.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The serialized trace as bytes.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bytes</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.trace.Trace.load_pickle", "modulename": "dapy.sim.trace", "qualname": "Trace.load_pickle", "kind": "function", "doc": "<p>Deserialize a trace from a pickle byte string.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  The serialized trace as bytes.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A Trace instance deserialized from the byte string.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>TypeError:</strong>  If the deserialized object is not a Trace instance.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.trace.Trace.dump_json", "modulename": "dapy.sim.trace", "qualname": "Trace.dump_json", "kind": "function", "doc": "<p>Serialize the trace to a JSON string.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The serialized trace as a JSON string.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>ImportError:</strong>  If classifiedjson is not installed. Install with:\nuv pip install dapy[json]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "dapy.sim.trace.Trace.load_json", "modulename": "dapy.sim.trace", "qualname": "Trace.load_json", "kind": "function", "doc": "<p>Deserialize a trace from a JSON string.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  The serialized trace as a JSON string.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A Trace instance deserialized from the JSON string.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>ImportError:</strong>  If classifiedjson is not installed. Install with:\nuv pip install dapy[json]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();